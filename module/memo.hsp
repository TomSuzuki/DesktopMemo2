
// メモのウィンドウを制御するためのモジュールです。

#module modMemo fname,x,y,w,h,col,memo,wid,hMesbox,boxid,hBrush,btnid,btnid_pin,btnid_col,btnid_del
#uselib "user32"
#cfunc GetWindowLong "GetWindowLongA" int, int
#func SetWindowLong "SetWindowLongA" int, int, int
#define GWL_STYLE	$FFFFFFF0
#define GWL_EXSTYLE -20
#define WS_EX_TOOLWINDOW	0x0080

#define margin 3
#define default_w 256
#define default_h 192
#define max_w 500
#define max_h 500

#modinit str _fname

	sdim memo,0xFFFFFF
	
	// 空ファイルの生成
	if _fname == ""{
		fname = strf("%s/%04d%02d%02d%02d%02d%02d%02d.memo",DATA_FOLDER,gettime(0),gettime(1),gettime(3),gettime(4),gettime(5),gettime(6),gettime(7))
		temp = ""
		notesel temp
		notesave fname
		noteunsel
	}else{
		// ロード
		fname = _fname
		notesel notedata
		noteload fname
		noteget temp,0
		split temp,",",x,y,w,h,col
		repeat noteinfo(0)-1,1
			if noteinfo(0)-1 < 0:break
			noteget temp,cnt
			if cnt != 1:memo += "\n"
			memo += temp
		loop
		noteunsel
	}


	// 初期化
	x = int(x)
	y = int(y)
	w = int(w)
	h = int(h)
	col = col
	wid = ginfo_newid

	// 最低値
	if w < default_w:w = default_w
	if h < default_h:h = default_h
	if w > max_w:w = max_w
	if h > max_h:h = max_h

	// ウィンドウの生成
	bgscr wid,ginfo(20),ginfo(21),2,x,y
	width w,h

	// 色の設定

	// コマンドの登録
	title "desktop memo"
	SetWindowLong hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_TOOLWINDOW
	oncmd gosub *onWindowClick@,0x0201
	oncmd gosub *onWindowResize@,0x00005

	// 背景色など
	color decRGB(get_WindowColor(thismod)):boxf

	// メッセージボックスの登録
	objmode 2,0
	font BOX_FONT,FONT_SIZE,FONT_OPTION
	pos margin,32+margin
	mesbox memo,ginfo_winx-2*margin,ginfo_winy-32-2*margin,1,0xFFFFFF
	boxid = stat
	hMesbox = objinfo(stat,2)
	ShowScrollBar hMesbox,3,0
	SetWindowLong hMesbox,-20,0
	SetWindowPos hMesbox,0,0,0,0,0,0x27
	CreateSolidBrush get_WindowBkColor(thismod)
	hBrush = stat

	// ボタンイメージの生成（関数化する）
	btnid = ginfo_newid
	buffer btnid,32,32*3*4
	gsel btnimage
	repeat 4
		y = cnt*96
		color decRGB(0xCCCCCC):boxf 0,y+00,31,y+32
		color decRGB(0xFFFFFF):boxf 0,y+32,31,y+64
		color decRGB(0xAAAAAA):boxf 0,y+64,31,y+96
	loop
	gsel btnid
	color decRGB(get_WindowColor(thismod))
	boxf
	gmode 7,32,32*3*4
	pos 0,0
	gcopy btnimage

	// ボタンの設置
	gsel wid
	objsize 32,32
	y = 32*3*0:objimage btnid,0,y+32*0,0,y+32*1,0,y+32*2:pos 32*0,0:button gosub "",*newWindow@
	y = 32*3*1:objimage btnid,0,y+32*0,0,y+32*1,0,y+32*2:pos 32*1,0:button gosub "",*newWindow@:btnid_pin = stat
	y = 32*3*2:objimage btnid,0,y+32*0,0,y+32*1,0,y+32*2:pos 32*2,0:button gosub "",*newWindow@:btnid_col = stat
	y = 32*3*3:objimage btnid,0,y+32*0,0,y+32*1,0,y+32*2:pos ginfo_winx-32,0:button gosub "",*delWindow@:btnid_del = stat
	
	// 表示
	gsel wid,1

	oncmd gosub *ctrlEdit@, 0x133
	
	return

// デストラクタ
#modterm
	DeleteObject hBrush
	return


// 情報が更新された（保存を行う）
#modfunc onChange
	sel = ginfo_sel
	gsel wid
	options = ""
	options += str(ginfo_wx1) + ","
	options += str(ginfo_wy1) + ","
	options += str(ginfo_winx) + ","
	options += str(ginfo_winy) + ","
	options += str("") + "\n"
	temp = options + str(memo)
	notesel temp
	notesave fname
	noteunsel
	gsel sel
	return

// ゲッター
#modcfunc get_WindowColor
	return 0x111111
#modcfunc get_WindowTextColor
	return 0xFFFFFF
#modcfunc get_WindowBkColor
	return 0x222222
#modcfunc get_hMesbox
	return hMesbox
#modcfunc get_hBrush
	return hBrush
#modcfunc get_wid
	return wid
#modcfunc get_boxid
	return boxid
#modcfunc get_btnid_pin
	return btnid_pin
#modcfunc get_btnid_col
	return btnid_col
#modcfunc get_btnid_del
	return btnid_del
#modcfunc get_fname
	return fname
	
#global

// モジュール内に書くとランタイムエラーとかになるので...
goto *module_memo

// ウィンドウの削除
*delWindow
	foreach window
		if ginfo(2) == get_wid(window(cnt)) {
			gsel get_wid(window(cnt)),-1
			delete get_fname(window(cnt))
			break
		}
	loop
	return

// ウィンドウの追加
*newWindow
	newmod window,modMemo,""
	return

// ウィンドウのリサイズ
*onWindowResize
	foreach window
		if ginfo(2) == get_wid(window(cnt)) {
			gsel ginfo(2),0
			size = ginfo_winx-2*margin,ginfo_winy-32-2*margin,0,0
			resizeobj get_boxid(window(cnt)),size,1
			onChange window(cnt)
			break
		}
	loop
	return

// ウィンドウのクリック
*onWindowClick
	foreach window
		if ginfo(2) == get_wid(window(cnt)) {
			gsel ginfo(2),0
			sendmsg hwnd,0x00A1,2,0
			onChange window(cnt)
			break
		}
	loop
	return

// エディットコントロールの処理（主に色のための処理）
*ctrlEdit
	await 1
	hBrush = 0
	foreach window
		if get_hMesbox(window(cnt)) == lparam {
			textColor = get_WindowTextColor(window(cnt))
			bkColor   = get_WindowBkColor(window(cnt))
			hBrush    = get_hBrush(window(cnt))
			SetTextColor wparam, textColor
			SetBkColor wparam, bkColor
			onChange window(cnt)
			break
		}
	loop
	return hBrush


*module_memo
